"use strict";(self.webpackChunkveezoo_docs=self.webpackChunkveezoo_docs||[]).push([[5909],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),u=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},m=function(e){var n=u(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),d=u(t),p=a,f=d["".concat(l,".").concat(p)]||d[p]||c[p]||s;return t?r.createElement(f,i(i({ref:n},m),{},{components:t})):r.createElement(f,i({ref:n},m))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o[d]="string"==typeof e?e:a,i[1]=o;for(var u=2;u<s;u++)i[u]=t[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6265:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return d}});var r=t(7462),a=t(3366),s=(t(7294),t(3905)),i=["components"],o={id:"measure",title:"measure",sidebar_label:"What is a measure?"},l=void 0,u={unversionedId:"reference/kb-layer/measure/measure",id:"reference/kb-layer/measure/measure",title:"measure",description:"Definition",source:"@site/docs/reference/kb-layer/measure/measure.md",sourceDirName:"reference/kb-layer/measure",slug:"/reference/kb-layer/measure/",permalink:"/docs/reference/kb-layer/measure/",draft:!1,editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/kb-layer/measure/measure.md",tags:[],version:"current",frontMatter:{id:"measure",title:"measure",sidebar_label:"What is a measure?"},sidebar:"docs",previous:{title:"onto.CalendarTable",permalink:"/docs/reference/kb-layer/attribute/extends/calendar-table"},next:{title:"What is a function?",permalink:"/docs/reference/kb-layer/function/"}},m={},d=[{value:"Definition",id:"definition",level:2},{value:"Usage",id:"usage",level:2},{value:"Examples",id:"examples",level:2},{value:"Basic Measures",id:"basic-measures",level:3},{value:"Measures with Filters",id:"measures-with-filters",level:3},{value:"Boolean filters",id:"boolean-filters",level:4},{value:"Entity filters",id:"entity-filters",level:4},{value:"Numeric filters",id:"numeric-filters",level:4},{value:"Measures using other classes",id:"measures-using-other-classes",level:3},{value:"Compositional Measures",id:"compositional-measures",level:3}],c={toc:d},p="wrapper";function f(e){var n=e.components,t=(0,a.Z)(e,i);return(0,s.kt)(p,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"definition"},"Definition"),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"measure")," is a computed numeric aggregation, which you would want to refer to in questions directly or in other measure definitions."),(0,s.kt)("h2",{id:"usage"},"Usage"),(0,s.kt)("p",null,"A ",(0,s.kt)("inlineCode",{parentName:"p"},"measure")," is usually defined inside a top-level class (e.g. Order) and has the following properties:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx",metastring:'title="knowledge-base/classes/Order/class.vkl"',title:'"knowledge-base/classes/Order/class.vkl"'},'kb {\n\n    class Order {\n        ...\n\n        measure Revenue {\n\n            /** The name of the measure so you can refer to it in questions.\n             *  If this measure is just an intermediate definition, which should not be used in questions, use display_name instead. */ \n            name.en: "Revenue"\n\n            /** The return type of the measure. Currently, it can be either a number (or sometimes more specifically an integer). */\n            return: number\n\n            /** The definition of the measure. This is written in VQL (Veezoo Query Language), which is our optimized syntax to define measures. */\n            definition: """\n                sum(this.Order_Amount)\n            """\n        }\n    }\n}\n')),(0,s.kt)("p",null,"Let's go over some examples to understand how to use measures in Veezoo."),(0,s.kt)("h2",{id:"examples"},"Examples"),(0,s.kt)("h3",{id:"basic-measures"},"Basic Measures"),(0,s.kt)("p",null,"First of all, in Veezoo, unlike in other BI tools, you don't need to define a measure to be able to ask questions involving aggregations.\nFor instance, you don't need to have an \"average order amount\" explicitly defined to be able to ask about it, since Veezoo knows what average means. This also applies to totals (e.g. total order amount), counts (e.g. number of users) and even percentages (e.g. percentage of First Class orders)."),(0,s.kt)("p",null,"However, sometimes you will still want to define explicitly the measure. The main case we see in Veezoo is when the name of the measure doesn't capture completely the logic behind it.\nYou may also want to add a description to it and display it more prominently in Autocomplete to guide users better."),(0,s.kt)("p",null,"Let's start with simple examples:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n\n        ...\n\n        /** A numeric value defined in the database. */\n        number Order_Amount {\n            ...\n        }\n\n        measure Revenue {\n            name.en: "Revenue"\n            return: number\n\n            definition: """\n                sum(this.Order_Amount)\n            """            \n        }\n\n        measure Avg_Order_Value {\n            name.en: "Average Order Value"\n            return: number\n\n            definition: """\n                average(this.Order_Amount)\n            """ \n        }\n\n        measure Number_of_Orders { \n            name.en: "Number of Orders"\n            return: integer\n\n            definition: """\n                count(this)\n            """\n        } \n    }\n}\n')),(0,s.kt)("p",null,"The first thing you notice is the usage of the word ",(0,s.kt)("inlineCode",{parentName:"p"},"this"),". It refers to the top-level class this measure is based on, in this case: ",(0,s.kt)("inlineCode",{parentName:"p"},"kb.Order"),"."),(0,s.kt)("h3",{id:"measures-with-filters"},"Measures with Filters"),(0,s.kt)("p",null,'As mentioned before, a common case for measures is when there is a non-obvious logic to it, meaning it is not in the name of the measure itself. "Revenue in Germany" for instance does not need to be defined as a measure if Germany is just a country in the database. But maybe "Revenue" itself would require a flag \'is_cancelled\' to be false or another filter to be set.'),(0,s.kt)("h4",{id:"boolean-filters"},"Boolean filters"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n        ...\n\n        number Order_Amount { ... }\n\n        boolean is_Cancelled { ... }\n\n        measure Revenue {\n            name.en: "Revenue"\n            \n            description.en: "Revenue only includes orders that were not cancelled"\n\n            return: number\n\n            definition: """\n                this.is_Cancelled = false\n\n                sum(this.Order_Amount)\n            """\n        }\n\n    }\n}\n')),(0,s.kt)("p",null,"Alternatively, if the boolean filter needs to be true, we would have had ",(0,s.kt)("inlineCode",{parentName:"p"},"this.is_Active = true"),"."),(0,s.kt)("h4",{id:"entity-filters"},"Entity filters"),(0,s.kt)("p",null,"What if we didn't have a boolean flag, but rather a specific entity (e.g. 'Active') that we needed to filter for?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n        ...\n\n        number Order_Amount { ... }\n\n        /** Possible Status: Cancelled, Active, On_Hold */\n        class Status { ... }\n\n        measure Revenue {\n            name.en: "Revenue"\n            \n            description.en: "Revenue only includes orders that were active."\n\n            return: number\n\n            definition: """\n                this.Status = kb.Order.Status.Active    # alternatively, you can also use a string directly, e.g. "Active"\n\n                sum(this.Order_Amount)\n            """\n        }\n\n    }\n}\n')),(0,s.kt)("p",null,"What if you need to filter out an entity, e.g. not cancelled? Let's see just how the ",(0,s.kt)("inlineCode",{parentName:"p"},"definition")," changes:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'definition: """\n    this.Status != kb.Order.Status.Cancelled\n\n    sum(this.Order_Amount)\n"""\n')),(0,s.kt)("p",null,"Finally, maybe there are multiple statuses that you need to consider. For this case, we use a ",(0,s.kt)("inlineCode",{parentName:"p"},"union"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'definition: """\n    this.Status = union(kb.Order.Status.Active, kb.Order.Status.On_Hold)\n\n    sum(this.Order_Amount)\n"""\n')),(0,s.kt)("h4",{id:"numeric-filters"},"Numeric filters"),(0,s.kt)("p",null,"Let's say instead that to calculate Revenue, we should ignore all orders with negative Order_Amount."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'definition: """\n    this.Order_Amount >= 0\n\n    sum(this.Order_Amount)\n"""\n')),(0,s.kt)("p",null,"For numeric filters, we support: ",(0,s.kt)("inlineCode",{parentName:"p"},"<"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"<="),", ",(0,s.kt)("inlineCode",{parentName:"p"},">")," and ",(0,s.kt)("inlineCode",{parentName:"p"},">="),". We also support numeric operators like ",(0,s.kt)("inlineCode",{parentName:"p"},"*"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"/")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"-"),"."),(0,s.kt)("h3",{id:"measures-using-other-classes"},"Measures using other classes"),(0,s.kt)("p",null,"What if for Revenue we actually need to filter out customers that are inactive (according to a separate class and table)?"),(0,s.kt)("p",null,"This is how the measure definition would change:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n        ...\n\n        relationship from_Customer { ... }\n        \n        measure Revenue {\n            name.en: "Revenue"\n            \n            description.en: "Revenue only includes orders from active customers."\n\n            return: number\n\n            definition: """\n                var c: kb.Customer     # think of this like the following SQL: FROM customers c\n\n                this.from_Customer = c\n                c.is_Active = true\n\n                sum(this.Order_Amount)\n            """\n        }\n\n    }\n}\n')),(0,s.kt)("p",null,"This can be made shorter:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'definition: """\n    this.from_Customer.is_Active = true\n\n    sum(this.Order_Amount)\n"""\n')),(0,s.kt)("p",null,"Now, let's go a bit wild. What if Revenue should be defined as total order amount only from customers that had at least 2 orders at any point in time."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'definition: """\n\n    var c: kb.Customer\n\n    # c is this order\'s customer\n    this.from_Customer = c\n\n    var o: kb.Order         # these are separate orders\n    o.from_Customer = c     # from the same customer\n    \n    # let\'s count these orders here for each customer\n    # the parenthesis are required\n    var number_of_orders = count(o) by (c)\n    \n    # only those customers with at least 2 orders\n    number_of_orders >= 2\n\n    sum(this.Order_Amount)\n"""\n')),(0,s.kt)("p",null,'It is important to notice here that if you ask "Revenue this month", Veezoo will compute the revenue from orders this month with customers that at any point in time did at least 2 orders, not restricted to this month. This happens because we introduce a new order ',(0,s.kt)("inlineCode",{parentName:"p"},"var o: kb.Order")," that does not have any of the filters from ",(0,s.kt)("inlineCode",{parentName:"p"},"this"),"."),(0,s.kt)("h3",{id:"compositional-measures"},"Compositional Measures"),(0,s.kt)("p",null,"Sometimes we will want to reuse existing measures in new definitions, because we depend on them or because we want to keep the code more readable."),(0,s.kt)("p",null,"Let's say we want to define gross profit margin in %. We will start by defining it in one measure."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n        ...\n\n        number Gross_Profit_Margin { ... }\n\n        number Sale_Price { ... }\n        \n        measure Gross_Profit_Margin_Percentage {\n            name.en: "Gross Profit Margin (in %)"\n\n            return: number\n\n            # So we can see in %\n            unit: onto.Percentage\n\n            definition: """\n                var total_gpm = sum(this.Gross_Profit_Margin)\n                var total_sale = sum(this.Sale_Price)\n\n                (total_gpm / total_sale) * 100      # Multiply by 100 so we get a percentage\n            """\n        }\n\n    }\n}\n')),(0,s.kt)("p",null,"Alternatively, you could also define it shorter as ",(0,s.kt)("inlineCode",{parentName:"p"},"(sum(this.Gross_Profit_Margin) / sum(this.Sale_Price)) * 100"),"."),(0,s.kt)("p",null,"Great. But this assumes that gross profit margin and sale price just require a sum. As we have seen before, these could be arbitrarily complex."),(0,s.kt)("p",null,"So let's say we have two measures ",(0,s.kt)("inlineCode",{parentName:"p"},"Total_Gross_Profit_Margin")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"Total_Sale_Price"),". And now we will define it again using these measures."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'kb {\n\n    class Order {\n        ...\n\n        measure Total_Gross_Profit_Margin { ... }\n\n        measure Total_Sale_Price { ... }\n        \n        measure Gross_Profit_Margin_Percentage {\n            name.en: "Gross Profit Margin (in %)"\n\n            return: number\n\n            # So we can see in %\n            unit: onto.Percentage\n\n            definition: """\n                var total_gpm = kb.Order.Total_Gross_Profit_Margin(this)\n                var total_sale = kb.Order.Total_Sale_Price(this)\n\n                (total_gpm / total_sale) * 100      # Multiply by 100 so we get a percentage\n            """\n        }\n\n    }\n}\n')),(0,s.kt)("p",null,"The syntax to refer to a measure is similar to an aggregation function (e.g. sum, count), meaning it takes an argument. The argument is usually ",(0,s.kt)("inlineCode",{parentName:"p"},"this"),", which is the top-level class with all the filters from the question."))}f.isMDXComponent=!0}}]);