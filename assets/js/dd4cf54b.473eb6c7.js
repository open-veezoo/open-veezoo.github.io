"use strict";(self.webpackChunkveezoo_docs=self.webpackChunkveezoo_docs||[]).push([[1521],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return k}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),u=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(r),m=a,k=p["".concat(s,".").concat(m)]||p[m]||c[m]||o;return r?n.createElement(k,i(i({ref:t},d),{},{components:r})):n.createElement(k,i({ref:t},d))}));function k(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},4473:function(e,t,r){r.r(t),r.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return k},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return p}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),i=["components"],l={},s="VQL (Veezoo Query Language)",u={unversionedId:"reference/kb-layer/vql/vql",id:"reference/kb-layer/vql/vql",title:"VQL (Veezoo Query Language)",description:"The Veezoo Query Language (VQL) acts as a bridge between natural language and SQL. When users pose questions to Veezoo, the intelligent Veezoo model translates these queries into VQL, which is then deterministically transformed into SQL.",source:"@site/docs/reference/kb-layer/vql/vql.md",sourceDirName:"reference/kb-layer/vql",slug:"/reference/kb-layer/vql/",permalink:"/docs/reference/kb-layer/vql/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"reference",previous:{title:"Rule",permalink:"/docs/reference/kb-layer/rule/"},next:{title:"What is a function?",permalink:"/docs/reference/kb-layer/function/"}},d={},p=[{value:"Variables and Select",id:"variables-and-select",level:2},{value:"Showing Attributes",id:"showing-attributes",level:3},{value:"Filters",id:"filters",level:2},{value:"Negation",id:"negation",level:3},{value:"String Filters",id:"string-filters",level:3},{value:"Joins",id:"joins",level:2},{value:"Dates",id:"dates",level:2},{value:"Date Filters",id:"date-filters",level:3},{value:"Relative Dates",id:"relative-dates",level:3},{value:"Aggregation Functions",id:"aggregation-functions",level:2},{value:"Aggregation Over Time",id:"aggregation-over-time",level:3},{value:"Arithmetic Functions",id:"arithmetic-functions",level:2},{value:"Percentages",id:"percentages",level:3},{value:"Union",id:"union",level:2},{value:"Subqueries",id:"subqueries",level:2},{value:"Types of Subqueries",id:"types-of-subqueries",level:3},{value:"Inline Subqueries",id:"inline-subqueries",level:4},{value:"Named Subqueries (CTEs)",id:"named-subqueries-ctes",level:4}],c={toc:p},m="wrapper";function k(e){var t=e.components,r=(0,a.Z)(e,i);return(0,o.kt)(m,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"vql-veezoo-query-language"},"VQL (Veezoo Query Language)"),(0,o.kt)("p",null,"The Veezoo Query Language (VQL) acts as a bridge between natural language and SQL. When users pose questions to Veezoo, the intelligent Veezoo model translates these queries into VQL, which is then deterministically transformed into SQL. "),(0,o.kt)("p",null,"VQL offers the same expressiveness as SQL but operates at a higher abstraction level by utilizing the classes and attributes defined in the Veezoo Knowledge Graph instead of directly working on underlying tables and columns."),(0,o.kt)("p",null,"While viewer-users don't need access to VQL for everyday tasks, creator-users can benefit significantly from understanding VQL, particularly because:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When Veezoo answers a question, it provides both the SQL and the corresponding VQL used. VQL is often shorter and more human-readable.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Measures, functions, and rules are defined using VQL, making it an essential tool for creators looking to leverage Veezoo's advanced capabilities."))),(0,o.kt)("h2",{id:"variables-and-select"},"Variables and Select"),(0,o.kt)("p",null,"Let's take a look at a simple VQL query that returns a list of all products:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var product from kb.Product\n\nselect(product)\n")),(0,o.kt)("p",null,"A typical VQL query starts by defining variables. Similar to many programming languages, variables in VQL can represent different types, such as:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("a",{parentName:"li",href:"/docs/reference/kb-layer/attribute/number"},"number"),", ",(0,o.kt)("a",{parentName:"li",href:"/docs/reference/kb-layer/attribute/string"},"string"),", or ",(0,o.kt)("a",{parentName:"li",href:"/docs/reference/kb-layer/attribute/boolean"},"boolean")),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("a",{parentName:"li",href:"#dates"},"date")),(0,o.kt)("li",{parentName:"ul"},"a specific ",(0,o.kt)("a",{parentName:"li",href:"/docs/reference/kb-layer/entity/"},"entity")," of a class"),(0,o.kt)("li",{parentName:"ul"},"a ",(0,o.kt)("a",{parentName:"li",href:"/docs/reference/kb-layer/class"},"class")," itself, as in this case ",(0,o.kt)("inlineCode",{parentName:"li"},"var product from kb.Product"))),(0,o.kt)("p",null,"In VQL, a variable like ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," doesn\u2019t represent a single instance of the class but instead refers to ",(0,o.kt)("em",{parentName:"p"},"all possible instances"),". Think of a class in VQL as corresponding to an entire column or table in SQL."),(0,o.kt)("p",null,"Finally, ",(0,o.kt)("inlineCode",{parentName:"p"},"select(product)")," specifies what the query will return. This is similar to the ",(0,o.kt)("inlineCode",{parentName:"p"},"SELECT")," statement in SQL.\nThere must be one ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," statement at the end of every VQL query. Subqueries also use ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," at the end, see the section on ",(0,o.kt)("a",{parentName:"p",href:"#subqueries"},"subqueries"),"."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The VQL shown to users when answers are generated is not directly translated to SQL but undergoes several rewriting steps: rewriting rules are applied, functions are replaced by their definitions, and ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/kb-layer/class/display_with"},(0,o.kt)("inlineCode",{parentName:"a"},"display_with"))," is added."),(0,o.kt)("p",{parentName:"admonition"},"The rewriting happens after the VQL is shown, keeping the shown VQL easier to understand. However, it can make it harder to see how a particular VQL translates to SQL.")),(0,o.kt)("h3",{id:"showing-attributes"},"Showing Attributes"),(0,o.kt)("p",null,"In VQL, if you want to display additional attributes, you can do it like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var product from kb.Product\nvar category from kb.Product.Category\n\ncategory = product.Category\n\nselect(product, category)\n")),(0,o.kt)("p",null,"Here, we define a second variable called ",(0,o.kt)("inlineCode",{parentName:"p"},"category"),", which is of type ",(0,o.kt)("inlineCode",{parentName:"p"},"kb.Product.Category"),". In the third line, we assign ",(0,o.kt)("inlineCode",{parentName:"p"},"category")," to represent the categories associated with ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," using the dot-operator. The expression ",(0,o.kt)("inlineCode",{parentName:"p"},"product.Category")," indicates that the class represented by ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," has an attribute or a relationship called ",(0,o.kt)("inlineCode",{parentName:"p"},"Category"),"."),(0,o.kt)("p",null,"Make sure to explicitly connect the different variables in the VQL. Veezoo won't do that automatically for you."),(0,o.kt)("p",null,"Note that the dot-operator used here is different from the one in the first two lines, where it is part of the type's path."),(0,o.kt)("p",null,"This VQL can be simplified to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var product from kb.Product\nvar category = product.Category\n\nselect(product, category)\n")),(0,o.kt)("p",null,"In this case, the variable type is inferred automatically. The code can be further shortened (as Veezoo would generate it):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var product from kb.Product\n\nselect(product, product.Category)\n")),(0,o.kt)("h2",{id:"filters"},"Filters"),(0,o.kt)("p",null,"In most cases, we don't want to just return one or more attributes; we want to filter them based on certain criteria. For example, the following VQL will be generated when asking ",(0,o.kt)("em",{parentName:"p"},"Show me Orders from the Region West"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\norder.Region = kb.Order.Region.West\nselect(order)\n")),(0,o.kt)("p",null,"The second line here performs the filtering. Instead of overwriting something (as one might expect from other programming languages), we restrict the variable ",(0,o.kt)("inlineCode",{parentName:"p"},"order")," to only those with a ",(0,o.kt)("inlineCode",{parentName:"p"},"Region")," equal to the entity ",(0,o.kt)("inlineCode",{parentName:"p"},"kb.Order.Region.West"),"."),(0,o.kt)("p",null,"Filtering for numeric conditions can be done using mathematical comparisons (e.g., ",(0,o.kt)("em",{parentName:"p"},"Show orders with a quantity greater than 5"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar quantity = order.Quantity\nquantity > 5\nselect(order, quantity)\n")),(0,o.kt)("h3",{id:"negation"},"Negation"),(0,o.kt)("p",null,"Use the ",(0,o.kt)("inlineCode",{parentName:"p"},"not{}")," function to negate filters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customer from kb.Customer\n\nnot {\n  var order from kb.Order\n  order.Customer = customer\n}\nselect(customer)\n")),(0,o.kt)("p",null,"Here, all customers without any orders are returned. It filters for no possible value within the curly brackets."),(0,o.kt)("h3",{id:"string-filters"},"String Filters"),(0,o.kt)("p",null,"For attributes of type string, Veezoo provides the following filter functions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"starts_with_string()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"contains_string()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"ends_with_string()"))),(0,o.kt)("p",null,"These functions take two arguments: the string to be filtered and the value to compare it to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var customer from kb.Customer\n\nvar name = customer.fullName\nstarts_with_string(name, "Lukas")\nselect(name, customer)\n')),(0,o.kt)("p",null,"Here, we select customers whose full name starts with ",(0,o.kt)("em",{parentName:"p"},"Lukas"),"."),(0,o.kt)("p",null,"All of these string filters are case-insensitive."),(0,o.kt)("h2",{id:"joins"},"Joins"),(0,o.kt)("p",null,"Connecting two classes in VQL, which corresponds to joining two tables in SQL or accessing a column of a class, works similarly to filtering entities. For example, here is the VQL for the question ",(0,o.kt)("em",{parentName:"p"},"Show me all orders from customers with segment consumer"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar customer = order.with_Customer\ncustomer.Segment = kb.Customer.Segment.Consumer\n\nselect(order, customer)\n")),(0,o.kt)("p",null,"In the second line, we connect the order and customer classes, which will join the order and customer tables in SQL. We define the ",(0,o.kt)("inlineCode",{parentName:"p"},"customer")," variable to be the customers from the orders, i.e. ",(0,o.kt)("inlineCode",{parentName:"p"},"order.with_Customer"),",  which will be mapped to the ",(0,o.kt)("inlineCode",{parentName:"p"},"customer")," foreign key column in the order table in SQL."),(0,o.kt)("p",null,"In the next line, we specify that we only want customers with the segment ",(0,o.kt)("inlineCode",{parentName:"p"},"Consumer"),". Since the orders and customers are already connected, this filter also affects the orders."),(0,o.kt)("p",null,"Finally, we return the orders and their customers."),(0,o.kt)("h2",{id:"dates"},"Dates"),(0,o.kt)("p",null,"VQL has rich support for ",(0,o.kt)("a",{parentName:"p",href:"/docs/reference/kb-layer/attribute/date"},"dates"),", allowing you to filter and convert them to different granularities. "),(0,o.kt)("h3",{id:"date-filters"},"Date Filters"),(0,o.kt)("p",null,"If a class has a ",(0,o.kt)("inlineCode",{parentName:"p"},"date")," field, filtering for dates can be done similarly to filtering for other numeric values:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\n\nvar orderDate = order.Order_Date\norderDate > date("2022-05-01")\nselect(order, orderDate)\n')),(0,o.kt)("p",null,"The expression ",(0,o.kt)("inlineCode",{parentName:"p"},'date("2022-05-01")')," returns a date object for May 1st, 2022."),(0,o.kt)("p",null,"To filter for dates within a specific period, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"date_in()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\n\nvar orderDate = order.Order_Date\ndate_in(orderDate, date("2023"))\nselect(order, orderDate)\n')),(0,o.kt)("p",null,"Similarly, the ",(0,o.kt)("inlineCode",{parentName:"p"},"date_in_range()")," function can be used to filter for dates between a start and end point:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'date_in_range(date("1995-10-24"), orderDate, date("2008-05-13"))\n')),(0,o.kt)("h3",{id:"relative-dates"},"Relative Dates"),(0,o.kt)("p",null,"Besides static dates (which refer to a fixed point in time) VQL also offers support for relative dates like ",(0,o.kt)("em",{parentName:"p"},"this year")," or ",(0,o.kt)("em",{parentName:"p"},"last month"),". This is helpful in keeping dashboards up to date. If a widget is created by asking the question ",(0,o.kt)("em",{parentName:"p"},"How many orders last week"),", the widget will show data for the week prior to the current date, instead of always keeping to show data for the week before the question was asked."),(0,o.kt)("p",null,"Basic relative dates can be expressed using the ",(0,o.kt)("inlineCode",{parentName:"p"},"date()")," function with special keywords starting with ",(0,o.kt)("inlineCode",{parentName:"p"},"#"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\n\nvar orderDate = order.Order_Date\ndate_in(orderDate, date("#thisYear"))\nselect(order, orderDate)\n')),(0,o.kt)("p",null,"These values include:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Current"),(0,o.kt)("th",{parentName:"tr",align:null},"Last"),(0,o.kt)("th",{parentName:"tr",align:null},"Next"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#thisYear")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#lastYear")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#nextYear"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#thisQuarter")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#lastQuarter")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#nextQuarter"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#thisMonth")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#lastMonth")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#nextMonth"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#thisWeek")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#lastWeek")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#nextWeek"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#today")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#yesterday")),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#tomorrow"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"#now")),(0,o.kt)("td",{parentName:"tr",align:null},"\u2014"),(0,o.kt)("td",{parentName:"tr",align:null},"\u2014")))),(0,o.kt)("p",null,"More complex relative dates can be build up using ",(0,o.kt)("inlineCode",{parentName:"p"},"date_add"),', e.g. "Number of orders in the last 30 days vs. the same period last year":'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\n\nvar orderDate = order.order_Date\nvar year = {\n  # Between 29 days ago and today\n  between(orderDate, date_add(date("#today"), -29, periodicity("P1D")), date("#today"))\n} union {\n  # Between 29 days ago last year and today last year\n  between(orderDate, date_add(date_add(date("#today"), -29, periodicity("P1D")), -1, periodicity("P1Y")), date_add(date("#today"), -1, periodicity("P1Y")))\n}\nvar retCount = count(order) by (year)\nselect(year, retCount)\n')),(0,o.kt)("h2",{id:"aggregation-functions"},"Aggregation Functions"),(0,o.kt)("p",null,"VQL aggregation functions work similarly to SQL:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\nvar profit = order.Profit\nvar sumProfit = sum(profit)\nselect(sumProfit)\n")),(0,o.kt)("p",null,"Similar to SQL, you may also perform multiple aggregations in parallel, using the following syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar profit = order.Profit\n\nvar (sumProfit, averageProfit, countOrder) = (sum(profit), average(profit), count(order))\n\nselect(sumProfit, averageProfit, countOrder)\n")),(0,o.kt)("p",null,"The aggregation functions can also be used directly in the final ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," statement:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar profit = order.Profit\nselect(sum(profit), average(profit), count(order))\n")),(0,o.kt)("p",null,"As in SQL, aggregation functions can be grouped by one or more attributes. For example, if we want the ",(0,o.kt)("em",{parentName:"p"},"Average Profit of Orders by Shipping Mode"),", instead of calculating the average profit for all orders, we divide the orders into groups based on their shipping mode and then calculate the average per group:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar shippingMode = order.Shipping_Mode\nselect(average(order.Profit) by (shippingMode), shippingMode)\n")),(0,o.kt)("p",null,"The shipping mode must be included in the ",(0,o.kt)("inlineCode",{parentName:"p"},"select")," statement (not just in the ",(0,o.kt)("inlineCode",{parentName:"p"},"by")," clause) so that users can see which case the aggregated numbers represent. Let's look at another example, ",(0,o.kt)("em",{parentName:"p"},"Average Profit of Orders by Shipping Mode and Region"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nvar region = order.Region\nvar shippingMode = order.Shipping_Mode\nselect(average(order.Profit) by (shippingMode, region), shippingMode, region)\n")),(0,o.kt)("h3",{id:"aggregation-over-time"},"Aggregation Over Time"),(0,o.kt)("p",null,"A common form of aggregation is over a certain timespan, such as day, week, or year. This involves some extra steps. The following example calculates the ",(0,o.kt)("em",{parentName:"p"},"Average Discount of Orders by Week"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\nvar week = periodicity("P1W")\n\nvar orderDate = order.Order_Date\nproject_date(orderDate, week)\nselect(average(sum(order.Discount) by (week)))\n')),(0,o.kt)("p",null,"The line ",(0,o.kt)("inlineCode",{parentName:"p"},'var week = periodicity("P1W")')," defines the time duration for aggregation. The variable ",(0,o.kt)("inlineCode",{parentName:"p"},"week")," is then passed into the ",(0,o.kt)("inlineCode",{parentName:"p"},"project_date()")," function, where the ",(0,o.kt)("inlineCode",{parentName:"p"},"week")," periodicity is assigned the week of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Order_Date"),". Finally, we can aggregate by week."),(0,o.kt)("h2",{id:"arithmetic-functions"},"Arithmetic Functions"),(0,o.kt)("p",null,"VQL supports arithmetic functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"+"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"-"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"/"),", or ",(0,o.kt)("inlineCode",{parentName:"p"},"*")," to perform calculations. For example, to calculate the total order value minus the value-added tax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var order from kb.Order\n\nselect(sum(order.value - order.VAT))\n")),(0,o.kt)("p",null,"Arithmetic functions can also be used with grouped aggregations. Here, we calculate the same value but grouped by month:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'var order from kb.Order\nvar month = periodicity("P1M")\n\nproject_date(order.order_date, month)\nselect(sum(order.value) by (month) - sum(order.VAT) by (month), month)\n')),(0,o.kt)("p",null,"In such cases, both operands need to be aggregated at the same level of granularity."),(0,o.kt)("h3",{id:"percentages"},"Percentages"),(0,o.kt)("p",null,"To calculate percentages, VQL provides the ",(0,o.kt)("inlineCode",{parentName:"p"},"proportion() {}")," function. For example, to calculate the percentage of customers who live in Zurich:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customer from kb.Customer\n\nvar proportion = proportion(customer) {\n  customer.lives_in = kb.City.Zurich\n}\nselect(proportion)\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"proportion()")," function works by calculating the overall count or sum as the denominator, and then applying the filter inside the curly braces to calculate a restricted count or sum as the numerator."),(0,o.kt)("p",null,"This means that, for example, if an ",(0,o.kt)("inlineCode",{parentName:"p"},"order")," has a ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," and a ",(0,o.kt)("inlineCode",{parentName:"p"},"VAT"),", it is NOT possible to use this function to calculate what percentage of the value the VAT represents, since ",(0,o.kt)("inlineCode",{parentName:"p"},"order.VAT")," is not a subset of ",(0,o.kt)("inlineCode",{parentName:"p"},"order.value"),"."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"proportion() {}")," function can also be used with grouped data. For instance, to calculate the same percentage but grouped by customer segment:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customer from kb.Customer\n\nvar segment = customer.customer_segment\nvar proportion = proportion(customer) {\n  customer.lives_in = kb.City.Zurich\n} by (segment)\nselect(segment, proportion)\n")),(0,o.kt)("h2",{id:"union"},"Union"),(0,o.kt)("p",null,"In many cases, users want to filter for multiple possible options. For example, ",(0,o.kt)("em",{parentName:"p"},"Show customers from Zurich and Ljubljana")," or ",(0,o.kt)("em",{parentName:"p"},"Show premium customers and customers with high cancellation risk"),". To achieve this, Veezoo provides two versions of the ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," function."),(0,o.kt)("p",null,"In simpler scenarios, where you want to combine different entities of the same class (as in the first example), you can do it like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customer from kb.Customer\n\nvar city = union(kb.City.Zurich, kb.City.Ljubljana)\ncustomer.lives_in = city\n\nselect(city, customer)\n")),(0,o.kt)("p",null,"Here, ",(0,o.kt)("inlineCode",{parentName:"p"},"var city")," represents the union of Zurich and Ljubljana, and the following line filters out all customers who do not live in either city. The ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," function can include any number of entities."),(0,o.kt)("p",null,"For more complex cases, where you want to combine different conditions, the syntax changes. In the following case we want to select customers, which are either premium customers, or have a high cancellation risk associated with them:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customer from kb.Customer\n\nvar caseIdentifier = {\n  customer.is_premium = true\n} union {\n  customer.cancellation_risk = kb.Customer.cancellation_risk.high\n}\n\nselect(caseIdentifier, customer)\n")),(0,o.kt)("p",null,"This version of the ",(0,o.kt)("inlineCode",{parentName:"p"},"union")," function does two things:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It restricts ",(0,o.kt)("inlineCode",{parentName:"li"},"customer")," to those who are either premium OR have a high cancellation risk."),(0,o.kt)("li",{parentName:"ul"},"It creates ",(0,o.kt)("inlineCode",{parentName:"li"},"var caseIdentifier"),", which contains labels for all the possible cases that are part of the union. This is also selected, allowing the user to see why a particular customer is shown (e.g., ",(0,o.kt)("em",{parentName:"li"},"Yanick Brecher")," is shown because he is a ",(0,o.kt)("em",{parentName:"li"},"premium customer"),").")),(0,o.kt)("h2",{id:"subqueries"},"Subqueries"),(0,o.kt)("p",null,"VQL supports subqueries, which allow you to break down complex queries into smaller, more manageable parts. Subqueries are particularly useful for improving readability, avoiding code duplication, and creating intermediate results that can be reused multiple times within a query."),(0,o.kt)("h3",{id:"types-of-subqueries"},"Types of Subqueries"),(0,o.kt)("p",null,"VQL offers two ways to work with subqueries:"),(0,o.kt)("h4",{id:"inline-subqueries"},"Inline Subqueries"),(0,o.kt)("p",null,"Inline subqueries are defined using curly braces ",(0,o.kt)("inlineCode",{parentName:"p"},"{ ... }")," and can be used directly with the ",(0,o.kt)("inlineCode",{parentName:"p"},"from")," keyword:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var customerRevenue from {\n  var order from kb.Order\n  var customer = order.Customer\n  var revenue = sum(order.Revenue) by (customer)\n  select(customer, revenue)\n}\n\ncustomerRevenue.revenue > 1000\nselect(customerRevenue.customer, customerRevenue.revenue)\n")),(0,o.kt)("h4",{id:"named-subqueries-ctes"},"Named Subqueries (CTEs)"),(0,o.kt)("p",null,"Named subqueries work similarly to Common Table Expressions (CTEs) in SQL. They are defined at the beginning of a query using the ",(0,o.kt)("inlineCode",{parentName:"p"},"query")," keyword and can be reused multiple times:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"# Find customers who have placed more orders than the average\n\n# First, calculate the number of orders per customer\n# This subquery will be used multiple times\nquery customerOrderCounts = {\n  var order from kb.Order\n  var customer = order.Customer\n  var orderCount = count(order) by (customer)\n  select(customer, orderCount)\n}\n\n# Calculate the average (first use of subquery)\nvar avgRow from {\n  var customerData from customerOrderCounts\n  var avgOrders = average(customerData.orderCount)\n  select(avgOrders)\n}\n\n# Find customers above average (second use of subquery)\nvar customerData from customerOrderCounts\ncustomerData.orderCount > avgRow.avgOrders\nselect(customerData.customer, customerData.orderCount)\n")))}k.isMDXComponent=!0}}]);