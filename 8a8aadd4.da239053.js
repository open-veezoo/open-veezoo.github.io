(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{61:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return r})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return c}));var a=t(2),i=t(6),l=(t(0),t(77)),o={id:"kb-layer",title:"Knowledge Base Layer",sidebar_label:"Knowledge Base Layer",slug:"/kb-layer"},r={unversionedId:"fundamentals/kb-layer",id:"fundamentals/kb-layer",isDocsHomePage:!1,title:"Knowledge Base Layer",description:"The knowledge-base layer (kb) is where the magic happens. The idea behind the kb layer is to model your data semantically, i.e. as if you would be explaining to a person what your database is really about.",source:"@site/docs/fundamentals/kb-layer.md",slug:"/kb-layer",permalink:"/docs/kb-layer",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/fundamentals/kb-layer.md",version:"current",sidebar_label:"Knowledge Base Layer",sidebar:"someSidebar",previous:{title:"Database Layer",permalink:"/docs/db-layer"}},b=[{value:"Classes and Entities",id:"classes-and-entities",children:[{value:"VKL: Classes and Entities",id:"vkl-classes-and-entities",children:[]}]},{value:"Literal Types",id:"literal-types",children:[]},{value:"Relations",id:"relations",children:[{value:"VKL: Relations",id:"vkl-relations",children:[]}]}],s={rightToc:b};function c(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"knowledge-base")," layer (",Object(l.b)("inlineCode",{parentName:"p"},"kb"),") is where the magic happens. The idea behind the ",Object(l.b)("inlineCode",{parentName:"p"},"kb")," layer is to model your data semantically, i.e. as if you would be explaining to a person what your database is really about."),Object(l.b)("p",null,"For this modelling, we have to introduce a new vocabulary:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Classes"),Object(l.b)("li",{parentName:"ul"},"Entities"),Object(l.b)("li",{parentName:"ul"},"Relations"),Object(l.b)("li",{parentName:"ul"},"Literal types")),Object(l.b)("p",null,"Let's see in detail what each of these things actually mean."),Object(l.b)("h2",{id:"classes-and-entities"},"Classes and Entities"),Object(l.b)("p",null,"If you come from a software background, you may be familiar with the idea of a class as defined in object-oriented programming. In some sense, we are making your data more object-oriented.\nSo, a class can be defined as a category of things. The best way to understand it is to go over some examples."),Object(l.b)("p",null,"A class could be something like:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Customer")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Country")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Order")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Movie"))),Object(l.b)("p",null,'Now, each of these classes may have instantiations of it. In programming, we call these "objects". In VKL, we call them ',Object(l.b)("inlineCode",{parentName:"p"},"entities"),".\nSo following our example, we may have entities like:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Till_Haug")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Customer")," "),Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Brazil")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Country")),Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Batman")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Movie"))),Object(l.b)("p",null,"But what about ",Object(l.b)("inlineCode",{parentName:"p"},"Order"),"? For classes like ",Object(l.b)("inlineCode",{parentName:"p"},"Order"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Transaction")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Event"),", it makes sense usually to model it as a class without entities. Prefer to use classes with entities when there is a way to refer to an individual of this class in a question."),Object(l.b)("h3",{id:"vkl-classes-and-entities"},"VKL: Classes and Entities"),Object(l.b)("p",null,"Let's see how they are defined in VKL."),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Customer/class.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n    class Customer {\n        name.en: "Customer"     \n        synonym.en: ["Client"]\n        refersTo: onto.Customer\n        \n        semanticLink: {\n            entitiesDefinition: {\n                nameSqlPattern.en:\n                    "CONCAT(${ORDERS.customer_firstname}, \' \', ${ORDERS.customer_lastname})"    \n            }\n\n            idSqlPattern: "${ORDERS.customer_id}"\n        }\n    }\n}\n')),Object(l.b)("p",null,"Let's break it down in parts:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"name.en"),": The name of the class in the specified language (",Object(l.b)("inlineCode",{parentName:"li"},"en")," for English). This is the primary way to refer to this concept in a question and what gets displayed to the user in an answer."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"synonym.en"),': Synonyms specify alternative ways to refer to this concept in a question. In our example, we can say "how many customers", but also "how many clients" and it will mean the same.'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"refersTo"),": By using this optional attribute, you can point your class to a pre-defined ontology class and inherit labels and other functionalities from it. Studio already does this automatically to the best of its knowledge. To find out more about ontologies, check ","[Ontologies]",".")),Object(l.b)("p",null,"And then we get to the glue between the ",Object(l.b)("inlineCode",{parentName:"p"},"knowledge-base")," layer and the ",Object(l.b)("inlineCode",{parentName:"p"},"database")," layer, namely the Semantic Link. "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"idSqlPattern"),": Specifies in a SQL-like format how to uniquely identify an entity of this class in the database. Usually this is a key. In our example, this would be the ",Object(l.b)("inlineCode",{parentName:"li"},"customer_id")," for the customer class. For the class ",Object(l.b)("inlineCode",{parentName:"li"},"Order"),", we still define an ",Object(l.b)("inlineCode",{parentName:"li"},"idSqlPattern"),", even though we won't specify ",Object(l.b)("inlineCode",{parentName:"li"},"entitiesDefinition"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"entitiesDefinition"),": This block defines how entities will be generated for the given class.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"nameSqlPattern.en"),": Specifies in a SQL-like format how to generate the name for the entities of this class. In our example, this would be by concatenating the first name and the last name in SQL."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"synonymSqlPattern.en")," (optional): Specifies in a SQL-like format how to generate alternative ways to refer to the entities.")))),Object(l.b)("p",null,"It is important to notice that to be able to use the SQL table definitions with a short-hand notation, we had to import its reference in the header of the file (",Object(l.b)("inlineCode",{parentName:"p"},"import: [ db.postgres... ]"),")."),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Customer/entities.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb.Customer {\n    entity Till_Haug {          \n        name.en: "Till Haug"  // automatically generated\n\n        synonym.en: ["Tillio", "Mr. Haug"]  // manually added\n\n        sqlId: "1"  // automatically generated\n    }\n\n    ...\n}\n')),Object(l.b)("p",null,"As you can see here, we have ",Object(l.b)("inlineCode",{parentName:"p"},"name")," and ",Object(l.b)("inlineCode",{parentName:"p"},"sqlId")," automatically generated based on our definition in the class' ",Object(l.b)("inlineCode",{parentName:"p"},"semanticLink"),". You can freely add new synonyms over labels or adapt the ",Object(l.b)("inlineCode",{parentName:"p"},"name")," and see the effect straight away in Veezoo."),Object(l.b)("h2",{id:"literal-types"},"Literal Types"),Object(l.b)("p",null,"Literal types are your usual data types like: ",Object(l.b)("inlineCode",{parentName:"p"},"Double"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Date"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Boolean")," and ",Object(l.b)("inlineCode",{parentName:"p"},"String"),"."),Object(l.b)("h2",{id:"relations"},"Relations"),Object(l.b)("p",null,"A relation in VKL describes how classes and other classes or literal types relate to each other. "),Object(l.b)("p",null,"Example:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Till_Haug")," ",Object(l.b)("em",{parentName:"li"},"works at")," ",Object(l.b)("inlineCode",{parentName:"li"},"Veezoo_AG")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"JP_Monteiro")," ",Object(l.b)("em",{parentName:"li"},"was born on")," ",Object(l.b)("inlineCode",{parentName:"li"},"30th of March 1993")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Brazil")," ",Object(l.b)("em",{parentName:"li"},"has a population of")," ",Object(l.b)("inlineCode",{parentName:"li"},"209'500'000"))),Object(l.b)("p",null,"In other words, we have the following relations:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"works_at")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Employee")," to ",Object(l.b)("inlineCode",{parentName:"li"},"Company")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"birthdate")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Person")," to the literal type ",Object(l.b)("inlineCode",{parentName:"li"},"Date")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"population")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Country")," to the literal type ",Object(l.b)("inlineCode",{parentName:"li"},"Integer"))),Object(l.b)("h3",{id:"vkl-relations"},"VKL: Relations"),Object(l.b)("p",null,"Let's look now at our movie e-commerce example."),Object(l.b)("p",null,"Veezoo generates automatically relations and puts them in the file of its domain class, e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"population")," can be found inside ",Object(l.b)("inlineCode",{parentName:"p"},"kb.Country")," class definition."),Object(l.b)("p",null,"Relations, as we have seen, are binary and can be between:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"class")," and ",Object(l.b)("inlineCode",{parentName:"li"},"class")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"class")," and a literal type (",Object(l.b)("inlineCode",{parentName:"li"},"Date"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Boolean"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Double"),")")),Object(l.b)("p",null,"In general, the syntax is the same, but we will analyze them individually."),Object(l.b)("h4",{id:"relation-class---class"},"Relation: Class -> Class"),Object(l.b)("p",null,"Let's take the relation between ",Object(l.b)("inlineCode",{parentName:"p"},"Order")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Customer"),"."),Object(l.b)("p",null,"Extensive form:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ... \n\n        semanticLink: {\n            ...\n\n            idSqlPattern: "${ORDERS.id}"\n        }\n\n        ...\n\n        relation from_Customer {\n            displayName.en: "from"\n            tag: KB_Many2One\n\n            from: kb.Order\n            to: kb.Customer\n\n            semanticLink: {\n                from_sql: "${ORDERS.id}"\n                to_sql: "${ORDERS.customer_id}"\n            }\n        }\n    }\n}\n')),Object(l.b)("p",null,"These are the properties we have defined:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"displayName.en"),': This specifies how this relation gets displayed to the user in an answer, but is not used to refer to it in a question. In our example, we don\'t want the word "from" to be always taken to mean this relation in a question, so we specify it as a ',Object(l.b)("inlineCode",{parentName:"li"},"displayName"),", instead of a ",Object(l.b)("inlineCode",{parentName:"li"},"name"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to"),": This relation connects the class specified in ",Object(l.b)("inlineCode",{parentName:"li"},"from")," with the one in ",Object(l.b)("inlineCode",{parentName:"li"},"to"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"semanticLink"),": Defines how the relation is translated to SQL.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from_sql")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to_sql"),": Specifies where the classes in ",Object(l.b)("inlineCode",{parentName:"li"},"from")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to")," can be found for this relation, more specifically their ",Object(l.b)("inlineCode",{parentName:"li"},"id"),"s. In our example, ",Object(l.b)("inlineCode",{parentName:"li"},"ORDERS.customer_id")," uniquely refers to the class ",Object(l.b)("inlineCode",{parentName:"li"},"Customer"),"."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tag"),": Tags allow you to add additional information about a concept. For relation, we add always its cardinality, i.e. how many of ",Object(l.b)("inlineCode",{parentName:"li"},"from")," relate to how many of ",Object(l.b)("inlineCode",{parentName:"li"},"to"),". In our example, each customer can have multiple orders, but one order is assigned to one customer. This means: ",Object(l.b)("inlineCode",{parentName:"li"},"Order")," N--1 ",Object(l.b)("inlineCode",{parentName:"li"},"Customer"),", therefore ",Object(l.b)("inlineCode",{parentName:"li"},"KB_Many2One"),".")),Object(l.b)("p",null,"Now, as you have seen, there are some unnecessary repetition above. Since Veezoo is based on a DRY principle (Don't Repeat Yourself), Veezoo encourages you to hide certain properties. More specifically, "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from"),": this is the class the relation is in"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from_sql")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to_sql"),": for this relation, it is equal to the ",Object(l.b)("inlineCode",{parentName:"li"},"idSqlPattern")," from ",Object(l.b)("inlineCode",{parentName:"li"},"kb.Order")," and ",Object(l.b)("inlineCode",{parentName:"li"},"kb.Customer")," respectively. This would not be the case if for instance ",Object(l.b)("inlineCode",{parentName:"li"},"kb.Customer")," would actually have been defined in a separate table and referenced over a foreign key. In that case, the ",Object(l.b)("inlineCode",{parentName:"li"},"to_sql")," would be the foreign key column.")),Object(l.b)("p",null,"Shorthand form:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation from_Customer {\n            displayName.en: "from"\n            tag: KB_Many2One\n            to: kb.Customer\n        }\n    }\n}\n')),Object(l.b)("p",null,"Now we will explore the other kinds of relations with literals: ",Object(l.b)("inlineCode",{parentName:"p"},"Double")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Boolean"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Date")," and ",Object(l.b)("inlineCode",{parentName:"p"},"String"),"."),Object(l.b)("h4",{id:"relation-class---doubleinteger"},"Relation: Class -> Double/Integer"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Order.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation amount {\n            name.en: "Amount"\n            synonym.en: ["Price", "Revenue"]\n            to: Double\n\n            unit: onto.Unit.Currency.USD\n\n            semanticLink: {\n                to_sql: "${ORDERS.amount}"\n            }\n            \n            tag: KB_Many2One\n        }    \n    }\n}\n')),Object(l.b)("p",null,"Notice the ",Object(l.b)("inlineCode",{parentName:"p"},"unit")," parameter, which allows Veezoo to display the value in the appropriate format to the user."),Object(l.b)("p",null,"Also, differently than in the previous example, here we need to explicitly define ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql"),", since it cannot be inferred from the ",Object(l.b)("inlineCode",{parentName:"p"},"to")," attribute. This is the case for all literal relations, as you will see next."),Object(l.b)("h4",{id:"relation-class---date"},"Relation: Class -> Date"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Order.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation date {\n            name.en: "Date"\n            to: Date\n\n            dateTimeFormat: DayFormat\n\n            semanticLink: {\n                to_sql: "${ORDERS.date}"\n            }\n            \n            tag: KB_Many2One\n        }\n    }\n}\n')),Object(l.b)("p",null,"For Date relations, it is required to specify the granularity by setting ",Object(l.b)("inlineCode",{parentName:"p"},"dateTimeFormat"),". Also, Veezoo assumes that the ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," is a SQL date/datetime expression. This means that in case it is not, you should change ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," to be a casting operation in your SQL dialect, e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql: \"TO_DATE(${ORDERS.date_str}, 'YYYYMMDD')\"")," or directly in your database."),Object(l.b)("h4",{id:"relation-class---boolean"},"Relation: Class -> Boolean"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Order.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n        relation returned {\n            name.en: "Returned"\n            to: Boolean\n\n            semanticLink: {\n                to_sql: "${ORDERS.returned} = \'yes\'"\n            }\n            \n            tag: KB_Many2One\n        }\n    }\n}\n')),Object(l.b)("p",null,"For Boolean relations, the ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," is any kind of SQL boolean expression."),Object(l.b)("h4",{id:"relation-class---string"},"Relation: Class -> String"),Object(l.b)("p",null,"In our example, we didn't have any ",Object(l.b)("inlineCode",{parentName:"p"},"String")," relations, but let's say we would have a column in our database for ",Object(l.b)("inlineCode",{parentName:"p"},"returned_comment"),", so whenever customers return an order, they can specify why in free-text. In this case, it is not natural to model it as a class with entities. A comment doesn't have a name for you to refer to it in a question. But still you may want to explore its contents. "),Object(l.b)("p",null,"This is how we would model it in the Knowledge Graph:"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Order.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation comment {\n            name.en: "Comment"\n            synonym.en: ["Returned Comment", "Complaint", "Feedback"]\n            to: String\n\n            semanticLink: {\n                to_sql: "${ORDERS.returned_comment}"\n            }\n            \n            tag: KB_Many2One\n        }\n    }\n}\n')),Object(l.b)("p",null,"That's it. Like this, you can ask questions involving text search operations, e.g. \"how many customers complained about 'damaged' orders last week?\"."))}c.isMDXComponent=!0}}]);