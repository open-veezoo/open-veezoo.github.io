(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{71:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return o})),t.d(n,"rightToc",(function(){return b})),t.d(n,"default",(function(){return c}));var a=t(2),i=t(6),l=(t(0),t(90)),r={id:"kb-layer",title:"Knowledge Base Layer",sidebar_label:"Knowledge Base Layer",slug:"/kb-layer"},o={unversionedId:"fundamentals/kb-layer",id:"fundamentals/kb-layer",isDocsHomePage:!1,title:"Knowledge Base Layer",description:"The knowledge-base layer (kb) is where the magic happens. The idea behind the kb layer is to model your data semantically, i.e. as if you would be explaining to a person what your database is really about.",source:"@site/docs/fundamentals/kb-layer.md",slug:"/kb-layer",permalink:"/docs/kb-layer",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/fundamentals/kb-layer.md",version:"current",sidebar_label:"Knowledge Base Layer",sidebar:"someSidebar",previous:{title:"Database Layer",permalink:"/docs/db-layer"}},b=[{value:"Classes and Entities",id:"classes-and-entities",children:[{value:"VKL: Classes and Entities",id:"vkl-classes-and-entities",children:[]}]},{value:"Literal Types",id:"literal-types",children:[]},{value:"Relations",id:"relations",children:[{value:"VKL: Relations",id:"vkl-relations",children:[]}]}],s={rightToc:b};function c(e){var n=e.components,t=Object(i.a)(e,["components"]);return Object(l.b)("wrapper",Object(a.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(l.b)("p",null,"The ",Object(l.b)("inlineCode",{parentName:"p"},"knowledge-base")," layer (",Object(l.b)("inlineCode",{parentName:"p"},"kb"),") is where the magic happens. The idea behind the ",Object(l.b)("inlineCode",{parentName:"p"},"kb")," layer is to model your data semantically, i.e. as if you would be explaining to a person what your database is really about."),Object(l.b)("p",null,"For this modelling, we have to introduce a new vocabulary:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Classes"),Object(l.b)("li",{parentName:"ul"},"Entities"),Object(l.b)("li",{parentName:"ul"},"Relations"),Object(l.b)("li",{parentName:"ul"},"Literal types")),Object(l.b)("p",null,"Let's see in detail what each of these things actually mean."),Object(l.b)("h2",{id:"classes-and-entities"},"Classes and Entities"),Object(l.b)("p",null,"If you come from a software background, you may be familiar with the idea of a class as defined in object-oriented programming. In some sense, we are making your data more object-oriented.\nSo, a class can be defined as a category of things. The best way to understand it is to go over some examples."),Object(l.b)("p",null,"A class could be something like:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Customer")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Country")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Order")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Movie"))),Object(l.b)("p",null,'Now, each of these classes may have instantiations of it. In programming, we call these "objects". In VKL, we call them entities.\nSo following our example, we may have entities like:'),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Till_Haug")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Customer")," "),Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Brazil")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Country")),Object(l.b)("li",{parentName:"ul"},"entity ",Object(l.b)("inlineCode",{parentName:"li"},"Batman")," of class ",Object(l.b)("inlineCode",{parentName:"li"},"Movie"))),Object(l.b)("p",null,"But what about ",Object(l.b)("inlineCode",{parentName:"p"},"Order"),"? For classes like ",Object(l.b)("inlineCode",{parentName:"p"},"Order"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Transaction")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Event"),", it makes sense usually to model it as a class without (named) entities. Prefer to use classes with entities when there is a way to refer to an individual of this class in a question."),Object(l.b)("h3",{id:"vkl-classes-and-entities"},"VKL: Classes and Entities"),Object(l.b)("p",null,"Let's see how they are defined in VKL."),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Customer/class.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    class Customer {\n        name.en: "Customer"     \n        synonym.en: ["Client"]\n        refersTo: onto.Customer\n        \n        semanticLink: {\n            entitiesDefinition: {\n                nameSqlPattern.en:\n                    "CONCAT(${ORDERS.customer_firstname}, \' \', ${ORDERS.customer_lastname})"    \n            }\n\n            idSqlPattern: "${ORDERS.customer_id}"\n        }\n    }\n}\n')),Object(l.b)("p",null,"Let's break it down in parts:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"name.en"),": The name of the class in the specified language (",Object(l.b)("inlineCode",{parentName:"li"},"en")," for English). This is the primary way to refer to this concept in a question and what gets displayed to the user in an answer."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"synonym.en"),': Synonyms specify alternative ways to refer to this concept in a question. In our example, we can say "how many customers", but also "how many clients" and it will mean the same.'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"refersTo"),": By using this optional attribute, you can point your class to a pre-defined ontology class and inherit labels and other functionalities from it. Studio already does this automatically to the best of its knowledge. To find out more about ontologies, check ","[Ontologies]",".")),Object(l.b)("p",null,"And then we get to the glue between the ",Object(l.b)("inlineCode",{parentName:"p"},"knowledge-base")," layer and the ",Object(l.b)("inlineCode",{parentName:"p"},"database")," layer, namely the Semantic Link. "),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"idSqlPattern"),": Specifies in a SQL-like format how to uniquely identify an entity of this class in the database. Usually this is a key. In our example, this would be the ",Object(l.b)("inlineCode",{parentName:"li"},"customer_id")," for the customer class. For the class ",Object(l.b)("inlineCode",{parentName:"li"},"Order"),", we still define an ",Object(l.b)("inlineCode",{parentName:"li"},"idSqlPattern"),", even though we won't specify ",Object(l.b)("inlineCode",{parentName:"li"},"entitiesDefinition"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"entitiesDefinition"),": This block defines how entities will be generated for the given class.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"nameSqlPattern.en"),": Specifies in a SQL-like format how to generate the name for the entities of this class. In our example, this would be by concatenating the first name and the last name in SQL."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"synonymSqlPattern.en")," (optional): Specifies in a SQL-like format how to generate alternative ways to refer to the entities.")))),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Customer/entities.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    class Customer {\n        entity Till_Haug {          \n            name.en: "Till Haug"  // automatically generated\n\n            synonym.en: ["Tillio", "Mr. Haug"]  // manually added\n\n            sqlId: "1"  // automatically generated\n        }\n\n        ...\n    }\n}\n')),Object(l.b)("p",null,"As you can see here, we have ",Object(l.b)("inlineCode",{parentName:"p"},"name")," and ",Object(l.b)("inlineCode",{parentName:"p"},"sqlId")," automatically generated based on our definition in the class' ",Object(l.b)("inlineCode",{parentName:"p"},"semanticLink"),". You can freely add new synonyms over labels or adapt the ",Object(l.b)("inlineCode",{parentName:"p"},"name")," and see the effect straight away in Veezoo."),Object(l.b)("h2",{id:"literal-types"},"Literal Types"),Object(l.b)("p",null,"Literal types are your usual data types like: ",Object(l.b)("inlineCode",{parentName:"p"},"Double"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Date"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Boolean")," and ",Object(l.b)("inlineCode",{parentName:"p"},"String"),"."),Object(l.b)("h2",{id:"relations"},"Relations"),Object(l.b)("p",null,"A relation in VKL describes how classes and other classes or literal types relate to each other. "),Object(l.b)("p",null,"Example:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Till_Haug")," ",Object(l.b)("em",{parentName:"li"},"works at")," ",Object(l.b)("inlineCode",{parentName:"li"},"Veezoo_AG")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"JP_Monteiro")," ",Object(l.b)("em",{parentName:"li"},"was born on")," ",Object(l.b)("inlineCode",{parentName:"li"},"30th of March 1993")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Brazil")," ",Object(l.b)("em",{parentName:"li"},"has a population of")," ",Object(l.b)("inlineCode",{parentName:"li"},"209'500'000"))),Object(l.b)("p",null,"In other words, we have the following relations:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"works_at")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Employee")," to ",Object(l.b)("inlineCode",{parentName:"li"},"Company")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"birthdate")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Person")," to the literal type ",Object(l.b)("inlineCode",{parentName:"li"},"Date")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"population")," is a relation that goes from ",Object(l.b)("inlineCode",{parentName:"li"},"Country")," to the literal type ",Object(l.b)("inlineCode",{parentName:"li"},"Integer"))),Object(l.b)("h3",{id:"vkl-relations"},"VKL: Relations"),Object(l.b)("p",null,"Let's look now at our movie e-commerce example."),Object(l.b)("p",null,"These are the relations created by Veezoo:"),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{})," ...\n    \u2514\u2500\u2500 relations\n        \u251c\u2500\u2500 order_Amount.vkl\n        \u251c\u2500\u2500 order_Country_To.vkl\n        \u251c\u2500\u2500 order_Customer_From.vkl\n        \u251c\u2500\u2500 order_Returned.vkl\n        \u251c\u2500\u2500 order_Date.vkl\n        \u2514\u2500\u2500 order_Movie_Of.vkl\n")),Object(l.b)("p",null,"Relations, as we have seen, are binary and can be between:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"class")," and ",Object(l.b)("inlineCode",{parentName:"li"},"class")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"class")," and a literal type (",Object(l.b)("inlineCode",{parentName:"li"},"Date"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Boolean"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"li"},"Double"),")")),Object(l.b)("p",null,"In general, the syntax is the same, but we will analyze them individually."),Object(l.b)("h4",{id:"relation-class---class"},"Relation: Class -> Class"),Object(l.b)("p",null,"Let's take the relation between ",Object(l.b)("inlineCode",{parentName:"p"},"Order")," and ",Object(l.b)("inlineCode",{parentName:"p"},"Customer"),"."),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    relation order_Customer_From {\n        displayName.en: "from"\n\n        from: kb.Order\n        to: kb.Customer\n\n        semanticLink: {\n            from_sql: "${ORDERS.order_id}"\n            to_sql: "${ORDERS.customer_id}"\n        }\n        \n        tag: KB_Many2One\n    }\n}\n')),Object(l.b)("p",null,"These are the properties we have defined:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"displayName.en"),': This specifies how this relation gets displayed to the user in an answer, but is not used to refer to it in a question. In our example, we don\'t want the word "from" to be always taken to mean this relation in a question, so we specify it as a ',Object(l.b)("inlineCode",{parentName:"li"},"displayName"),", instead of a ",Object(l.b)("inlineCode",{parentName:"li"},"name"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to"),": This relation connects the class specified in ",Object(l.b)("inlineCode",{parentName:"li"},"from")," with the one in ",Object(l.b)("inlineCode",{parentName:"li"},"to"),"."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"semanticLink"),": Defines how the relation is translated to SQL.",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"from_sql")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to_sql"),": Specifies where the classes in ",Object(l.b)("inlineCode",{parentName:"li"},"from")," and ",Object(l.b)("inlineCode",{parentName:"li"},"to")," can be found for this relation, more specifically their ",Object(l.b)("inlineCode",{parentName:"li"},"id"),"s. In our example, ",Object(l.b)("inlineCode",{parentName:"li"},"ORDERS.customer_id")," uniquely refers to the class ",Object(l.b)("inlineCode",{parentName:"li"},"Customer"),". This is the case even if it would just be a foreign key to another ",Object(l.b)("inlineCode",{parentName:"li"},"CUSTOMERS")," table."))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tag"),": Tags allow you to add additional information about a concept. For relation, we add always its cardinality, i.e. how many of ",Object(l.b)("inlineCode",{parentName:"li"},"from")," relate to how many of ",Object(l.b)("inlineCode",{parentName:"li"},"to"),". In our example, each customer can have multiple orders, but one order is assigned to one customer. This means: ",Object(l.b)("inlineCode",{parentName:"li"},"Order")," N--1 ",Object(l.b)("inlineCode",{parentName:"li"},"Customer"),", therefore ",Object(l.b)("inlineCode",{parentName:"li"},"KB_Many2One"),".")),Object(l.b)("p",null,"Now we will explore the other kinds of relations with literals: ",Object(l.b)("inlineCode",{parentName:"p"},"Double")," or ",Object(l.b)("inlineCode",{parentName:"p"},"Integer"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Boolean"),", ",Object(l.b)("inlineCode",{parentName:"p"},"Date")," and ",Object(l.b)("inlineCode",{parentName:"p"},"String"),"."),Object(l.b)("h4",{id:"relation-class---doubleinteger"},"Relation: Class -> Double/Integer"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/relations/order_Amount.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    relation order_Amount {\n        name.en: "Amount"\n        synonym.en: ["Price", "Revenue"]\n\n        from: kb.Order\n        to: Double\n\n        unit: onto.Unit.Currency.USD\n\n        semanticLink: {\n            from_sql: "${ORDERS.order_id}"\n            to_sql: "${ORDERS.amount}"\n        }\n        \n        tag: KB_Many2One\n    }\n}\n')),Object(l.b)("p",null,"Notice the ",Object(l.b)("inlineCode",{parentName:"p"},"unit")," parameter, which allows Veezoo to display the value in the appropriate format to the user."),Object(l.b)("h4",{id:"relation-class---date"},"Relation: Class -> Date"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/relations/order_Date.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    relation order_Date {\n        name.en: "Date"\n\n        from: kb.Order\n        to: Date\n\n        dateTimeFormat: DayFormat\n\n        semanticLink: {\n            from_sql: "${ORDERS.order_id}"\n            to_sql: "${ORDERS.date}"\n        }\n        \n        tag: KB_Many2One\n    }\n}\n')),Object(l.b)("p",null,"For Date relations, it is required to specify the granularity by setting ",Object(l.b)("inlineCode",{parentName:"p"},"dateTimeFormat"),". Also, Veezoo assumes that the ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," is a SQL date/datetime expression. This means that in case it is not, you should change ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," to be a casting operation in your SQL dialect, e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql: \"TO_DATE(${ORDERS.date_str}, 'YYYYMMDD')\"")," or directly in your database."),Object(l.b)("h4",{id:"relation-class---boolean"},"Relation: Class -> Boolean"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/relations/order_Returned.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    relation order_Returned {\n        name.en: "Returned"\n\n        from: kb.Order\n        to: Boolean\n\n        semanticLink: {\n            from_sql: "${ORDERS.order_id}"\n            to_sql: "${ORDERS.returned} = \'yes\'"\n        }\n        \n        tag: KB_Many2One\n    }\n}\n')),Object(l.b)("p",null,"For Boolean relations, the ",Object(l.b)("inlineCode",{parentName:"p"},"to_sql")," is any kind of SQL boolean expression."),Object(l.b)("h4",{id:"relation-class---string"},"Relation: Class -> String"),Object(l.b)("p",null,"In our example, we didn't have any ",Object(l.b)("inlineCode",{parentName:"p"},"String")," relations, but let's say we would have a column in our database for ",Object(l.b)("inlineCode",{parentName:"p"},"returned_comment"),", so whenever customers return an order, they can specify why in free-text. In this case, it is not natural to model it as a class with entities. A comment doesn't have a name for you to refer to it in a question. But still you may want to explore its contents. "),Object(l.b)("p",null,"This is how we would model it in the Knowledge Graph:"),Object(l.b)("p",null,"File: ",Object(l.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/relations/order_Comment.vkl")),Object(l.b)("pre",null,Object(l.b)("code",Object(a.a)({parentName:"pre"},{}),'kb {\n    relation order_Comment {\n        name.en: "Comment"\n        synonym.en: ["Returned Comment", "Complaint", "Feedback"]\n\n        from: kb.Order\n        to: String\n\n        semanticLink: {\n            from_sql: "${ORDERS.order_id}"\n            to_sql: "${ORDERS.returned_comment}"\n        }\n        \n        tag: KB_Many2One\n    }\n}\n')),Object(l.b)("p",null,"That's it. Like this, you can ask questions involving text search operations, e.g. \"how many customers complained about 'damaged' orders last week?\"."))}c.isMDXComponent=!0},90:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return u}));var a=t(0),i=t.n(a);function l(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){l(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function b(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)t=l[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=i.a.createContext({}),c=function(e){var n=i.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return i.a.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},p=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,l=e.originalType,r=e.parentName,s=b(e,["components","mdxType","originalType","parentName"]),d=c(t),p=a,u=d["".concat(r,".").concat(p)]||d[p]||m[p]||l;return t?i.a.createElement(u,o(o({ref:n},s),{},{components:t})):i.a.createElement(u,o({ref:n},s))}));function u(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var l=t.length,r=new Array(l);r[0]=p;var o={};for(var b in n)hasOwnProperty.call(n,b)&&(o[b]=n[b]);o.originalType=e,o.mdxType="string"==typeof e?e:a,r[1]=o;for(var s=2;s<l;s++)r[s]=t[s];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,t)}p.displayName="MDXCreateElement"}}]);