(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{102:function(e,n,r){"use strict";r.d(n,"a",(function(){return u})),r.d(n,"b",(function(){return O}));var t=r(0),o=r.n(t);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function i(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function l(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?i(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,t,o=function(e,n){if(null==e)return{};var r,t,o={},a=Object.keys(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||(o[r]=e[r]);return o}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)r=a[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var b=o.a.createContext({}),s=function(e){var n=o.a.useContext(b),r=n;return e&&(r="function"==typeof e?e(n):l(l({},n),e)),r},u=function(e){var n=s(e.components);return o.a.createElement(b.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return o.a.createElement(o.a.Fragment,{},n)}},d=o.a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,a=e.originalType,i=e.parentName,b=c(e,["components","mdxType","originalType","parentName"]),u=s(r),d=t,O=u["".concat(i,".").concat(d)]||u[d]||p[d]||a;return r?o.a.createElement(O,l(l({ref:n},b),{},{components:r})):o.a.createElement(O,l({ref:n},b))}));function O(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var a=r.length,i=new Array(a);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:t,i[1]=l;for(var b=2;b<a;b++)i[b]=r[b];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},88:function(e,n,r){"use strict";r.r(n),r.d(n,"frontMatter",(function(){return i})),r.d(n,"metadata",(function(){return l})),r.d(n,"rightToc",(function(){return c})),r.d(n,"default",(function(){return s}));var t=r(2),o=r(6),a=(r(0),r(102)),i={id:"to-double-integer",title:"to: Double/Integer",sidebar_label:"to: Double/Integer",slug:"/reference/kb-layer/relation/sql/double-integer"},l={unversionedId:"reference/kb-layer/relation/sql/to-double-integer",id:"reference/kb-layer/relation/sql/to-double-integer",isDocsHomePage:!1,title:"to: Double/Integer",description:"Definition",source:"@site/docs/reference/kb-layer/relation/sql/to-double-integer.md",slug:"/reference/kb-layer/relation/sql/double-integer",permalink:"/docs/reference/kb-layer/relation/sql/double-integer",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/kb-layer/relation/sql/to-double-integer.md",version:"current",sidebar_label:"to: Double/Integer",sidebar:"docs",previous:{title:"to: Date",permalink:"/docs/reference/kb-layer/relation/sql/date"},next:{title:"to: Boolean",permalink:"/docs/reference/kb-layer/relation/sql/boolean"}},c=[{value:"Definition",id:"definition",children:[]},{value:"Usage",id:"usage",children:[]}],b={rightToc:c};function s(e){var n=e.components,r=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(t.a)({},b,r,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"definition"},"Definition"),Object(a.b)("p",null,"A Numeric relation is used whenever you have a column or SQL expression that returns a number, e.g. an integer or a double."),Object(a.b)("h2",{id:"usage"},"Usage"),Object(a.b)("p",null,"File: ",Object(a.b)("em",{parentName:"p"},"hitchhiker/knowledge-base/classes/Order.vkl")),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-json"}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation Order_Total {\n            name.en: "Order Total"\n            synonym.en: ["Price", "Revenue", "Amount"]\n            to: Double\n\n            unit: onto.Currency.USD\n\n            sql: "${ORDERS.order_total}"\n        }    \n    }\n}\n')),Object(a.b)("p",null,"Notice the ",Object(a.b)("a",Object(t.a)({parentName:"p"},{href:"../unit"}),"unit")," parameter, which allows Veezoo to display the value in the appropriate format to the user."),Object(a.b)("p",null,"As with the other kinds of relations, you can also apply any kind of compatible SQL transformation inside ",Object(a.b)("inlineCode",{parentName:"p"},"sql"),"."),Object(a.b)("p",null,"Let's say instead that your relation ",Object(a.b)("inlineCode",{parentName:"p"},"kb.Order.Order_Total")," contains values in different currencies (USD, CHF, EUR), specified in the column ",Object(a.b)("inlineCode",{parentName:"p"},"ORDERS.currency")," (imported as class ",Object(a.b)("inlineCode",{parentName:"p"},"kb.Order.Currency"),").\nNow, summing these values up wouldn't make any sense. So we define a new relation ",Object(a.b)("inlineCode",{parentName:"p"},"Order_Total_EUR"),", which converts the values according to a fixed exchange rate."),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-json"}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation Order_Total_EUR {\n            name.en: "Order Total (EUR)"\n            synonym.en: ["Price", "Revenue", "Order Total"]\n\n            to: Double\n\n            unit: onto.Currency.EUR\n\n            sql: """\n                CASE ${kb.Order.Currency}\n                   WHEN \'USD\' THEN ${kb.Order.Order_Total} * 0.83\n                   WHEN \'CHF\' THEN ${kb.Order.Order_Total} * 0.92\n                   ELSE ${kb.Order.Order_Total}\n                END   \n            """\n\n        }    \n    }\n}\n')),Object(a.b)("p",null,"Notice here that we have referred inside the curly brackets ",Object(a.b)("inlineCode",{parentName:"p"},"${...}")," to a ",Object(a.b)("inlineCode",{parentName:"p"},"kb")," concept, instead of a ",Object(a.b)("inlineCode",{parentName:"p"},"db")," concept. This allows us to use recursively the definitions in the ",Object(a.b)("inlineCode",{parentName:"p"},"sql")," from these ",Object(a.b)("inlineCode",{parentName:"p"},"kb")," concepts. "),Object(a.b)("p",null,"For example, we could now build on top of ",Object(a.b)("inlineCode",{parentName:"p"},"kb.Order.Order_Total_EUR")," like this:"),Object(a.b)("pre",null,Object(a.b)("code",Object(t.a)({parentName:"pre"},{className:"language-json"}),'import: [\n    db.postgres.movie_db.public.ORDERS\n]\n\nkb {\n\n    class Order {\n\n        ...\n\n        relation Awesome {\n            name.en: "Awesome"\n\n            to: Boolean\n\n            sql: "${kb.Order.Order_Total_EUR} > 1000"\n\n        }    \n    }\n}\n')),Object(a.b)("p",null,"This is a ",Object(a.b)("a",Object(t.a)({parentName:"p"},{href:"boolean"}),"boolean relation"),', defining "awesome" orders as those with a total order value normalized in Euro above 1000. How awesome is that!'))}s.isMDXComponent=!0}}]);